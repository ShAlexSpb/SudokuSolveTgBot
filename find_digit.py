from PIL import Image
import cv2
import numpy as np
import os

def display_image(file_name):
    try:
        # Открываем изображение
        img = Image.open(file_name)
        # Отображаем изображение
        img.show()
    except FileNotFoundError:
        print(f"Файл '{file_name}' не найден.")
    except Exception as e:
        print(f"Произошла ошибка: {e}")


def find_template_occurrences(main_image_path: str, template_image_path: str, threshold: float = 0.8) -> list:
    """
    Ищет вхождения второй картинки в первую и возвращает список координат центров найденных совпадений.

    :param main_image_path: Путь к изображению, в котором ищем шаблон.
    :param template_image_path: Путь к изображению-шаблону.
    :param threshold: Порог совпадения (по умолчанию 0.8, то есть 80%).
    :return: Список координат (x, y) центров найденных шаблонов.
    """
    main_image = cv2.imread(main_image_path, cv2.IMREAD_GRAYSCALE)
    template_image = cv2.imread(template_image_path, cv2.IMREAD_GRAYSCALE)

    if main_image is None or template_image is None:
        print("Ошибка загрузки изображений.")
        return []

    template_h, template_w = template_image.shape
    result = cv2.matchTemplate(main_image, template_image, cv2.TM_CCOEFF_NORMED)
    locations = np.where(result >= threshold)

    match_points = [(x + template_w // 2, y + template_h // 2) for x, y in zip(*locations[::-1])]

    return match_points


def process_sudoku_matches(match_points: list, sudoku_grid: list, digit: int) -> list:
    """
    Записывает цифру в соответствующую ячейку судоку, если координата из match_points попадает внутрь одного из 81 квадратов.

    :param match_points: Массив координат совпадений.
    :param sudoku_grid: Исходный массив значений судоку.
    :param digit: Цифра, которую проверяем.
    :return: Обновленный массив значений судоку.
    """
    cell_bounds = [
        ((37, 290), (73, 335)),     # 1:1
        ((95, 290), (130, 335)),    # 1:2
        ((150, 290), (190, 335)),   # 1:3
        ((221, 290), (256, 335)),   # 1:4
        ((278, 290), (312, 335)),   # 1:5
        ((335, 290), (370, 335)),   # 1:6
        ((404, 290), (438, 335)),   # 1:7
        ((463, 290), (493, 335)),   # 1:8
        ((519, 290), (553, 335)),   # 1:9

        ((37, 351), (73, 391)),    # 2:1
        ((95, 351), (130, 391)),   # 2:2
        ((150, 351), (190, 391)),  # 2:3
        ((221, 351), (256, 391)),  # 2:4
        ((278, 351), (312, 391)),  # 2:5
        ((335, 351), (370, 391)),  # 2:6
        ((404, 351), (438, 391)),  # 2:7
        ((463, 351), (493, 391)),  # 2:8
        ((519, 351), (553, 391)),  # 2:9

        ((37, 408), (73, 448)),    # 3:1
        ((95, 408), (130, 448)),   # 3:2
        ((150, 408), (190, 448)),  # 3:3
        ((221, 408), (256, 448)),  # 3:4
        ((278, 408), (312, 448)),  # 3:5
        ((335, 408), (370, 448)),  # 3:6
        ((404, 408), (438, 448)),  # 3:7
        ((463, 408), (493, 448)),  # 3:8
        ((519, 408), (553, 448)),  # 3:9

        ((37, 477), (73, 515)),    # 4:1
        ((95, 477), (130, 515)),   # 4:2
        ((150, 477), (190, 515)),  # 4:3
        ((221, 477), (256, 515)),  # 4:4
        ((278, 477), (312, 515)),  # 4:5
        ((335, 477), (370, 515)),  # 4:6
        ((404, 477), (438, 515)),  # 4:7
        ((463, 477), (493, 515)),  # 4:8
        ((519, 477), (553, 515)),  # 4:9

        ((37, 534), (73, 574)),    # 5:1
        ((95, 534), (130, 574)),   # 5:2
        ((150, 534), (190, 574)),  # 5:3
        ((221, 534), (256, 574)),  # 5:4
        ((278, 534), (312, 574)),  # 5:5
        ((335, 534), (370, 574)),  # 5:6
        ((404, 534), (438, 574)),  # 5:7
        ((463, 534), (493, 574)),  # 5:8
        ((519, 534), (553, 574)),  # 5:9

        ((37, 592), (73, 632)),    # 6:1
        ((95, 592), (130, 632)),   # 6:2
        ((150, 592), (190, 632)),  # 6:3
        ((221, 592), (256, 632)),  # 6:4
        ((278, 592), (312, 632)),  # 6:5
        ((335, 592), (370, 632)),  # 6:6
        ((404, 592), (438, 632)),  # 6:7
        ((463, 592), (493, 632)),  # 6:8
        ((519, 592), (553, 632)),  # 6:9

        ((37, 655), (73, 705)),    # 7:1
        ((95, 655), (130, 705)),   # 7:2
        ((150, 655), (190, 705)),  # 7:3
        ((221, 655), (256, 705)),  # 7:4
        ((278, 655), (312, 705)),  # 7:5
        ((335, 655), (370, 705)),  # 7:6
        ((404, 655), (438, 705)),  # 7:7
        ((463, 655), (493, 705)),  # 7:8
        ((519, 655), (553, 705)),  # 7:9

        ((37, 715), (73, 760)),    # 8:1
        ((95, 715), (130, 760)),   # 8:2
        ((150, 715), (190, 760)),  # 8:3
        ((221, 715), (256, 760)),  # 8:4
        ((278, 715), (312, 760)),  # 8:5
        ((335, 715), (370, 760)),  # 8:6
        ((404, 715), (438, 760)),  # 8:7
        ((463, 715), (493, 760)),  # 8:8
        ((519, 715), (553, 760)),  # 8:9

        ((37, 771), (73, 820)),    # 9:1
        ((95, 771), (130, 820)),   # 9:2
        ((150, 771), (190, 820)),  # 9:3
        ((221, 771), (256, 820)),  # 9:4
        ((278, 771), (312, 820)),  # 9:5
        ((335, 771), (370, 820)),  # 9:6
        ((404, 771), (438, 820)),  # 9:7
        ((463, 771), (493, 820)),  # 9:8
        ((519, 771), (553, 820)),  # 9:9
    ]

    for x, y in match_points:
        for idx, ((x1, y1), (x2, y2)) in enumerate(cell_bounds):
            row, col = divmod(idx, 9)  # Определяем строку и столбец ячейки
            if x1 <= x <= x2 and y1 <= y <= y2:
                sudoku_grid[row][col] = digit  # Записываем цифру в нужную ячейку
                break  # Останавливаемся после первого совпадения

    return sudoku_grid


def sudoku_image_to_array(file_name: str) -> list:
    sudoku_array = [[0 for _ in range(9)] for _ in range(9)]

    for digit in range(1, 10):
        match_points = find_template_occurrences(file_name, "source_digit/" + str(digit) + "_ss.png", 0.9)
        process_sudoku_matches(match_points, sudoku_array, digit)

    return sudoku_array


def overlay_sudoku_solution(input_image_path: str, solved_grid: list):
    """
    Проходит по всем элементам массива solved_grid и накладывает соответствующее изображение цифры
    на изображение судоку в нужные координаты из cell_bounds.

    :param input_image_path: Путь к изображению судоку (JPG).
    :param solved_grid: 9x9 массив с решенной судоку.
    """
    cell_bounds = [
        ((37, 291), (73, 335)),  # 1:1
        ((95, 291), (130, 335)),  # 1:2
        ((150, 291), (190, 335)),  # 1:3
        ((221, 291), (256, 335)),  # 1:4
        ((278, 291), (312, 335)),  # 1:5
        ((335, 291), (370, 335)),  # 1:6
        ((404, 291), (438, 335)),  # 1:7
        ((463, 291), (493, 335)),  # 1:8
        ((519, 291), (553, 335)),  # 1:9

        ((37, 349), (73, 391)),  # 2:1
        ((95, 349), (130, 391)),  # 2:2
        ((150, 349), (190, 391)),  # 2:3
        ((221, 349), (256, 391)),  # 2:4
        ((278, 349), (312, 391)),  # 2:5
        ((335, 349), (370, 391)),  # 2:6
        ((404, 349), (438, 391)),  # 2:7
        ((463, 349), (493, 391)),  # 2:8
        ((519, 349), (553, 391)),  # 2:9

        ((37, 405), (73, 448)),  # 3:1
        ((95, 405), (130, 448)),  # 3:2
        ((150, 405), (190, 448)),  # 3:3
        ((221, 405), (256, 448)),  # 3:4
        ((278, 405), (312, 448)),  # 3:5
        ((335, 405), (370, 448)),  # 3:6
        ((404, 405), (438, 448)),  # 3:7
        ((463, 405), (493, 448)),  # 3:8
        ((519, 405), (553, 448)),  # 3:9

        ((37, 471), (73, 515)),  # 4:1
        ((95, 471), (130, 515)),  # 4:2
        ((150, 471), (190, 515)),  # 4:3
        ((221, 471), (256, 515)),  # 4:4
        ((278, 471), (312, 515)),  # 4:5
        ((335, 471), (370, 515)),  # 4:6
        ((404, 471), (438, 515)),  # 4:7
        ((463, 471), (493, 515)),  # 4:8
        ((519, 471), (553, 515)),  # 4:9

        ((37, 531), (73, 574)),  # 5:1
        ((95, 531), (130, 574)),  # 5:2
        ((150, 531), (190, 574)),  # 5:3
        ((221, 531), (256, 574)),  # 5:4
        ((278, 531), (312, 574)),  # 5:5
        ((335, 531), (370, 574)),  # 5:6
        ((404, 531), (438, 574)),  # 5:7
        ((463, 531), (493, 574)),  # 5:8
        ((519, 531), (553, 574)),  # 5:9

        ((37, 590), (73, 632)),  # 6:1
        ((95, 590), (130, 632)),  # 6:2
        ((150, 590), (190, 632)),  # 6:3
        ((221, 590), (256, 632)),  # 6:4
        ((278, 590), (312, 632)),  # 6:5
        ((335, 590), (370, 632)),  # 6:6
        ((404, 590), (438, 632)),  # 6:7
        ((463, 590), (493, 632)),  # 6:8
        ((519, 590), (553, 632)),  # 6:9

        ((37, 655), (73, 705)),  # 7:1
        ((95, 655), (130, 705)),  # 7:2
        ((150, 655), (190, 705)),  # 7:3
        ((221, 655), (256, 705)),  # 7:4
        ((278, 655), (312, 705)),  # 7:5
        ((335, 655), (370, 705)),  # 7:6
        ((404, 655), (438, 705)),  # 7:7
        ((463, 655), (493, 705)),  # 7:8
        ((519, 655), (553, 705)),  # 7:9

        ((37, 713), (73, 760)),  # 8:1
        ((95, 713), (130, 760)),  # 8:2
        ((150, 713), (190, 760)),  # 8:3
        ((221, 713), (256, 760)),  # 8:4
        ((278, 713), (312, 760)),  # 8:5
        ((335, 713), (370, 760)),  # 8:6
        ((404, 713), (438, 760)),  # 8:7
        ((463, 713), (493, 760)),  # 8:8
        ((519, 713), (553, 760)),  # 8:9

        ((37, 771), (73, 820)),  # 9:1
        ((95, 771), (130, 820)),  # 9:2
        ((150, 771), (190, 820)),  # 9:3
        ((221, 771), (256, 820)),  # 9:4
        ((278, 771), (312, 820)),  # 9:5
        ((335, 771), (370, 820)),  # 9:6
        ((404, 771), (438, 820)),  # 9:7
        ((463, 771), (493, 820)),  # 9:8
        ((519, 771), (553, 820)),  # 9:9
    ]

    # Загружаем изображение судоку
    base_image = cv2.imread(input_image_path)
    if base_image is None:
        print("Ошибка: Не удалось загрузить изображение судоку.")
        return

    # добавлена 21.02.25
    # очищает поле судоку, что бы не было наложений на стрые значения судоку
    overlay_path = f"source_digit/canvas_crop_x20_y280_w555.jpg"

    # Проверяем, существует ли изображение цифры
    if not os.path.exists(overlay_path):
        print(f"Ошибка: Не найден файл {overlay_path}")
        return

    # Загружаем изображение цифры
    overlay = cv2.imread(overlay_path)
    if overlay is None:
        print(f"Ошибка: Не удалось загрузить {overlay_path}")
        return

    # Получаем размеры накладываемого изображения
    h, w = overlay.shape[:2]

    # Накладываем изображение
    x = 20
    y = 280
    base_image[y:y + h, x:x + w] = overlay

    # Проходим по всему решенному судоку и накладываем соответствующие цифры
    for row in range(9):
        for col in range(9):
            digit = solved_grid[row][col]
            overlay_path = f"source_digit/{digit}_bb.png"

            # Проверяем, существует ли изображение цифры
            if not os.path.exists(overlay_path):
                print(f"Ошибка: Не найден файл {overlay_path}")
                continue

            # Загружаем изображение цифры
            overlay = cv2.imread(overlay_path)
            if overlay is None:
                print(f"Ошибка: Не удалось загрузить {overlay_path}")
                continue

            # Получаем координаты верхнего левого угла
            x, y = cell_bounds[row * 9 + col][0]
            x -= 8

            # Получаем размеры накладываемого изображения
            h, w = overlay.shape[:2]

            # Накладываем изображение
            base_image[y:y + h, x:x + w] = overlay

    # Генерируем имя выходного файла
    base_name, ext = os.path.splitext(input_image_path)
    output_image_path = f"{base_name}_solved{ext}"

    # Сохраняем изображение
    cv2.imwrite(output_image_path, base_image, [cv2.IMWRITE_JPEG_QUALITY, 95])
    print(f"Решенное судоку сохранено как {output_image_path}")

# Пример использования
if __name__ == "__main__":
    # Укажите путь к вашему изображению
    # image_file = input("Введите путь к файлу изображения: ")
    #display_image("downloads/photo_235.jpg")
    points = find_template_occurrences("downloads/photo_299.jpg", "source_digit/5_ss.png", 0.9)
    print(points)
    print(len(points))
    sudoku_grid = sudoku_image_to_array("downloads/photo_299.jpg")

    overlay_sudoku_solution("downloads/photo_299.jpg", sudoku_grid)

    for row in sudoku_grid:
        print(" ".join(map(str, row)))